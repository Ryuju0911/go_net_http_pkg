// Code generated by golang.org/x/tools/cmd/bundle. DO NOT EDIT.
//go:generate bundle -o=h2_bundle.go -prefix=http2 ../golang.org/x/net/http2

package http

import (
	"bufio"
	"bytes"
	"context"
	"crypto/tls"
	"fmt"
	"io"
	"log"
	"net"
	"net/golang.org/x/net/http2/hpack"
	"sync"
	"time"
)

// inflowMinRefresh is the minimum number of bytes we'll send for a
// flow control window update.
const http2inflowMinRefresh = 4 << 10

// inflow accounts for an inbound flow control window.
// It tracks both the latest window sent to the peer (used for enforcement)
// and the accumulated unsent window.
type http2inflow struct {
	avail  int32
	unsent int32
}

// init sets the initial window.
func (f *http2inflow) init(n int32) {
	f.avail = n
}

// add adds n bytes to the window, with a maximum window size of max,
// indicating that the peer can now send us more data.
// For example, the user read from a {Request,Response} body and consumed
// some of the buffered data, so the peer can now send more.
// It returns the number of bytes to send in a WINDOW_UPDATE frame to the peer.
// Window updates are accumulated and sent when the unsent capacity
// is at least inflowMinRefresh or will at least double the peer's available window.
func (f *http2inflow) add(n int) (connAdd int32) {
	if n < 0 {
		panic("negative update")
	}
	unsent := int64(f.unsent) + int64(n)
	// "A sender MUST NOT allow a flow-control window to exceed 2^31-1 octets."
	// RFC 7540 Section 6.9.1.
	const maxWindow = 1<<31 - 1
	if unsent+int64(f.avail) > maxWindow {
		panic("flow control update exceeds maximum window size")
	}
	f.unsent = int32(unsent)
	if f.unsent < http2inflowMinRefresh && f.unsent < f.avail {
		// If there aren't at least inflowMinRefresh bytes of window to send,
		// and this update won't at least double the window, buffer the update for later.
		return 0
	}
	f.avail += f.unsent
	f.unsent = 0
	return int32(unsent)
}

// outflow is the outbound flow control window's size.
type http2outflow struct {
	_ http2incomparable

	// n is the number of DATA bytes we're allowed to send.
	// An outflow is kept both on a conn and a per-stream.
	n int32
}

// add adds n bytes (positive or negative) to the flow control window.
// It returns false if the sum would exceed 2^31-1.
func (f *http2outflow) add(n int32) bool {
	sum := f.n + n
	if (sum > n) == (f.n > 0) {
		f.n = sum
		return true
	}
	return false
}

// A Frame is the base interface implemented by all frame types.
// Callers will generally type-assert the specific frame type:
// *HeadersFrame, *SettingsFrame, *WindowUpdateFrame, etc.
//
// Frames are only valid until the next call to Framer.ReadFrame.
type http2Frame interface {
}

// A Framer reads and writes Frames.
type http2Framer struct {
	r io.Reader
	// lastFrame Frame
	// errDetail error

	// countError is a non-nil func that's called on a frame parse
	// error with some unique error path token. It's initialized
	// from Transport.CountError or Server.CountError.
	countError func(errToken string)

	// // lastHeaderStream is non-zero if the last frame was an
	// // unfinished HEADERS/CONTINUATION.
	// lastHeaderStream uint32

	maxReadSize uint32
	// headerBuf   [frameHeaderLen]byte

	// TODO: let getReadBuf be configurable, and use a less memory-pinning
	// allocator in server.go to minimize memory pinned for many idle conns.
	// Will probably also need to make frame invalidation have a hook too.
	getReadBuf func(size uint32) []byte
	readBuf    []byte // cache for default getReadBuf

	// maxWriteSize uint32 // zero means unlimited; TODO: implement

	w io.Writer
	// wbuf []byte

	// // AllowIllegalWrites permits the Framer's Write methods to
	// // write frames that do not conform to the HTTP/2 spec. This
	// // permits using the Framer to test other HTTP/2
	// // implementations' conformance to the spec.
	// // If false, the Write methods will prefer to return an error
	// // rather than comply.
	// AllowIllegalWrites bool

	// // AllowIllegalReads permits the Framer's ReadFrame method
	// // to return non-compliant frames or frame orders.
	// // This is for testing and permits using the Framer to test
	// // other HTTP/2 implementations' conformance to the spec.
	// // It is not compatible with ReadMetaHeaders.
	// AllowIllegalReads bool

	// ReadMetaHeaders if non-nil causes ReadFrame to merge
	// HEADERS and CONTINUATION frames together and return
	// MetaHeadersFrame instead.
	ReadMetaHeaders *hpack.Decoder

	// MaxHeaderListSize is the http2 MAX_HEADER_LIST_SIZE.
	// It's used only if ReadMetaHeaders is set; 0 means a sane default
	// (currently 16MB)
	// If the limit is hit, MetaHeadersFrame.Truncated is set true.
	MaxHeaderListSize uint32

	// // TODO: track which type of frame & with which flags was sent
	// // last. Then return an error (unless AllowIllegalWrites) if
	// // we're in the middle of a header block and a
	// // non-Continuation or Continuation on a different stream is
	// // attempted to be written.

	// logReads, logWrites bool

	// debugFramer       *Framer // only use for logging written writes
	// debugFramerBuf    *bytes.Buffer
	debugReadLoggerf  func(string, ...interface{})
	debugWriteLoggerf func(string, ...interface{})

	// frameCache *frameCache // nil if frames aren't reused (default)
}

const (
	http2minMaxFrameSize = 1 << 14
	http2maxFrameSize    = 1<<24 - 1
)

// NewFramer returns a Framer that writes frames to w and reads them from r.
func http2NewFramer(w io.Writer, r io.Reader) *http2Framer {
	fr := &http2Framer{
		w:          w,
		r:          r,
		countError: func(string) {},
		// logReads:          logFrameReads,
		// logWrites:         logFrameWrites,
		debugReadLoggerf:  log.Printf,
		debugWriteLoggerf: log.Printf,
	}
	fr.getReadBuf = func(size uint32) []byte {
		if cap(fr.readBuf) >= int(size) {
			return fr.readBuf[:size]
		}
		fr.readBuf = make([]byte, size)
		return fr.readBuf
	}
	fr.SetMaxReadFrameSize(http2maxFrameSize)
	return fr
}

// SetMaxReadFrameSize sets the maximum size of a frame
// that will be read by a subsequent call to ReadFrame.
// It is the caller's responsibility to advertise this
// limit with a SETTINGS frame.
func (fr *http2Framer) SetMaxReadFrameSize(v uint32) {
	if v >= http2maxFrameSize {
		v = http2maxFrameSize
	}
	fr.maxReadSize = v
}

const (
	// NextProtoTLS is the NPN/ALPN protocol negotiated during
	// HTTP/2's TLS setup.
	http2NextProtoTLS = "h2"

	// https://httpwg.org/specs/rfc7540.html#SettingValues
	http2initialHeaderTableSize = 4096

	http2initialWindowSize = 65535 // 6.9.2 Initial Flow Control Window Size

	http2defaultMaxReadFrameSize = 1 << 20
)

// bufferedWriter is a buffered writer that writes to w.
// Its buffered writer is lazily allocated as needed, to minimize
// idle memory usage with many connections.
type http2bufferedWriter struct {
	_  http2incomparable
	w  io.Writer     // immutable
	bw *bufio.Writer // non-nil when data is buffered
}

func http2newBufferedWriter(w io.Writer) *http2bufferedWriter {
	return &http2bufferedWriter{w: w}
}

// bufWriterPoolBufferSize is the size of bufio.Writer's
// buffers created using bufWriterPool.
//
// TODO: pick a less arbitrary value? this is a bit under
// (3 x typical 1500 byte MTU) at least. Other than that,
// not much thought went into it.
const http2bufWriterPoolBufferSize = 4 << 10

var http2bufWriterPool = sync.Pool{
	New: func() interface{} {
		return bufio.NewWriterSize(nil, http2bufWriterPoolBufferSize)
	},
}

func (w *http2bufferedWriter) Write(p []byte) (n int, err error) {
	if w.bw == nil {
		bw := http2bufWriterPool.Get().(*bufio.Writer)
		bw.Reset(w.w)
		w.bw = bw
	}
	return w.bw.Write(p)
}

// incomparable is a zero-width, non-comparable type. Adding it to a struct
// makes that struct also non-comparable, and generally doesn't add
// any size (as long as it's first).
type http2incomparable [0]func()

// Server is an HTTP/2 server.
type http2Server struct {
	// // MaxHandlers limits the number of http.Handler ServeHTTP goroutines
	// // which may run at a time over all connections.
	// // Negative or zero no limit.
	// // TODO: implement
	// MaxHandlers int

	// // MaxConcurrentStreams optionally specifies the number of
	// // concurrent streams that each client may have open at a
	// // time. This is unrelated to the number of http.Handler goroutines
	// // which may be active globally, which is MaxHandlers.
	// // If zero, MaxConcurrentStreams defaults to at least 100, per
	// // the HTTP/2 spec's recommendations.
	// MaxConcurrentStreams uint32

	// MaxDecoderHeaderTableSize optionally specifies the http2
	// SETTINGS_HEADER_TABLE_SIZE to send in the initial settings frame. It
	// informs the remote endpoint of the maximum size of the header compression
	// table used to decode header blocks, in octets. If zero, the default value
	// of 4096 is used.
	MaxDecoderHeaderTableSize uint32

	// MaxEncoderHeaderTableSize optionally specifies an upper limit for the
	// header compression table used for encoding request headers. Received
	// SETTINGS_HEADER_TABLE_SIZE settings are capped at this limit. If zero,
	// the default value of 4096 is used.
	MaxEncoderHeaderTableSize uint32

	// MaxReadFrameSize optionally specifies the largest frame
	// this server is willing to read. A valid value is between
	// 16k and 16M, inclusive. If zero or otherwise invalid, a
	// default value is used.
	MaxReadFrameSize uint32

	// // PermitProhibitedCipherSuites, if true, permits the use of
	// // cipher suites prohibited by the HTTP/2 spec.
	// PermitProhibitedCipherSuites bool

	// // IdleTimeout specifies how long until idle clients should be
	// // closed with a GOAWAY frame. PING frames are not considered
	// // activity for the purposes of IdleTimeout.
	// IdleTimeout time.Duration

	// // MaxUploadBufferPerConnection is the size of the initial flow
	// // control window for each connections. The HTTP/2 spec does not
	// // allow this to be smaller than 65535 or larger than 2^32-1.
	// // If the value is outside this range, a default value will be
	// // used instead.
	// MaxUploadBufferPerConnection int32

	// // MaxUploadBufferPerStream is the size of the initial flow control
	// // window for each stream. The HTTP/2 spec does not allow this to
	// // be larger than 2^32-1. If the value is zero or larger than the
	// // maximum, a default value will be used instead.
	// MaxUploadBufferPerStream int32

	// NewWriteScheduler constructs a write scheduler for a connection.
	// If nil, a default scheduler is chosen.
	NewWriteScheduler func() http2WriteScheduler

	// CountError, if non-nil, is called on HTTP/2 server errors.
	// It's intended to increment a metric for monitoring, such
	// as an expvar or Prometheus metric.
	// The errType consists of only ASCII word characters.
	CountError func(errType string)

	// Internal state. This is a pointer (rather than embedded directly)
	// so that we don't embed a Mutex in this struct, which will make the
	// struct non-copyable, which might break some callers.
	state *http2serverInternalState
}

func (s *http2Server) maxReadFrameSize() uint32 {
	if v := s.MaxReadFrameSize; v >= http2minMaxFrameSize && v <= http2maxFrameSize {
		return v
	}
	return http2defaultMaxReadFrameSize
}

func (s *http2Server) maxDecoderHeaderTableSize() uint32 {
	if v := s.MaxDecoderHeaderTableSize; v > 0 {
		return v
	}
	return http2initialHeaderTableSize
}

func (s *http2Server) maxEncoderHeaderTableSize() uint32 {
	if v := s.MaxEncoderHeaderTableSize; v > 0 {
		return v
	}
	return http2initialHeaderTableSize
}

type http2serverInternalState struct {
	mu          sync.Mutex
	activeConns map[*http2serverConn]struct{}
}

func (s *http2serverInternalState) registerConn(sc *http2serverConn) {
	if s == nil {
		return // if the server was used without calling ConfigureServer
	}
	s.mu.Lock()
	s.activeConns[sc] = struct{}{}
	s.mu.Unlock()
}

func (s *http2serverInternalState) unregisterConn(sc *http2serverConn) {
	if s == nil {
		return // if the server was used without calling ConfigureServer
	}
	s.mu.Lock()
	delete(s.activeConns, sc)
	s.mu.Unlock()
}

// ConfigureServer adds HTTP/2 support to a net/http Server.
//
// The configuration conf may be nil.
//
// ConfigureServer must be called before s begins serving.
func http2ConfigureServer(s *Server, conf *http2Server) error {
	if s == nil {
		panic("nil *http.Server")
	}
	if conf == nil {
		conf = new(http2Server)
	}
	conf.state = &http2serverInternalState{activeConns: make(map[*http2serverConn]struct{})}
	// if h1, h2 := s, conf; h2.IdleTimeout == 0 {
	// 	if h1.IdleTimeout != 0 {
	// 		h2.IdleTimeout = h1.IdleTimeout
	// 	} else {
	// 		h2.IdleTimeout = h1.ReadTimeout
	// 	}
	// }
	// s.RegisterOnShutdown(conf.state.startGracefulShutdown)

	if s.TLSConfig == nil {
		s.TLSConfig = new(tls.Config)
	} else if s.TLSConfig.CipherSuites != nil && s.TLSConfig.MinVersion < tls.VersionTLS13 {
		// If they already provided a TLS 1.0–1.2 CipherSuite list, return an
		// error if it is missing ECDHE_RSA_WITH_AES_128_GCM_SHA256 or
		// ECDHE_ECDSA_WITH_AES_128_GCM_SHA256.
		haveRequired := false
		for _, cs := range s.TLSConfig.CipherSuites {
			switch cs {
			case tls.TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256,
				// Alternative MTI cipher to not discourage ECDSA-only servers.
				// See http://golang.org/cl/30721 for further information.
				tls.TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256:
				haveRequired = true
			}
		}
		if !haveRequired {
			return fmt.Errorf("http2: TLSConfig.CipherSuites is missing an HTTP/2-required AES_128_GCM_SHA256 cipher (need at least one of TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 or TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256)")
		}
	}

	// Note: not setting MinVersion to tls.VersionTLS12,
	// as we don't want to interfere with HTTP/1.1 traffic
	// on the user's server. We enforce TLS 1.2 later once
	// we accept a connection. Ideally this should be done
	// during next-proto selection, but using TLS <1.2 with
	// HTTP/2 is still the client's bug.

	s.TLSConfig.PreferServerCipherSuites = true

	if !http2strSliceContains(s.TLSConfig.NextProtos, http2NextProtoTLS) {
		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, http2NextProtoTLS)
	}
	if !http2strSliceContains(s.TLSConfig.NextProtos, "http/1.1") {
		s.TLSConfig.NextProtos = append(s.TLSConfig.NextProtos, "http/1.1")
	}

	if s.TLSNextProto == nil {
		s.TLSNextProto = map[string]func(*Server, *tls.Conn, Handler){}
	}
	protoHandler := func(hs *Server, c *tls.Conn, h Handler) {
		// if testHookOnConn != nil {
		// 	testHookOnConn()
		// }
		// The TLSNextProto interface predates contexts, so
		// the net/http package passes down its per-connection
		// base context via an exported but unadvertised
		// method on the Handler. This is for internal
		// net/http<=>http2 use only.
		var ctx context.Context
		type baseContexter interface {
			BaseContext() context.Context
		}
		if bc, ok := h.(baseContexter); ok {
			ctx = bc.BaseContext()
		}
		conf.ServeConn(c, &http2ServeConnOpts{
			Context:    ctx,
			Handler:    h,
			BaseConfig: hs,
		})
	}
	s.TLSNextProto[http2NextProtoTLS] = protoHandler
	return nil
}

// ServerConnOpts are options for the Server.ServeConn method.
type http2ServeConnOpts struct {
	// Context is the base context to use.
	// If nil, context.Background is used.
	Context context.Context

	// BaseConfig optionally sets the base configuration
	// for values. If nil, defaults are used.
	BaseConfig *Server

	// Handler specifies which handler to use for processing
	// requests. If nil, BaseConfig.Handler is used. If BaseConfig
	// or BaseConfig.Handler is nil, http.DefaultServeMux is used.
	Handler Handler

	// // UpgradeRequest is an initial request received on a connection
	// // undergoing an h2c upgrade. The request body must have been
	// // completely read from the connection before calling ServeConn,
	// // and the 101 Switching Protocols response written.
	// UpgradeRequest *http.Request

	// // Settings is the decoded contents of the HTTP2-Settings header
	// // in an h2c upgrade request.
	// Settings []byte

	// // SawClientPreface is set if the HTTP/2 connection preface
	// // has already been read from the connection.
	// SawClientPreface bool
}

func (o *http2ServeConnOpts) context() context.Context {
	if o != nil && o.Context != nil {
		return o.Context
	}
	return context.Background()
}

func (o *http2ServeConnOpts) baseConfig() *Server {
	if o != nil && o.Context != nil {
		return o.BaseConfig
	}
	return new(Server)
}

func (o *http2ServeConnOpts) handler() Handler {
	if o != nil {
		if o.Handler != nil {
			return o.Handler
		}
		if o.BaseConfig != nil && o.BaseConfig.Handler != nil {
			return o.BaseConfig.Handler
		}
	}
	return DefaultServeMux
}

// ServeConn serves HTTP/2 requests on the provided connection and
// blocks until the connection is no longer readable.
//
// ServeConn starts speaking HTTP/2 assuming that c has not had any
// reads or writes. It writes its initial settings frame and expects
// to be able to read the preface and settings frame from the
// client. If c has a ConnectionState method like a *tls.Conn, the
// ConnectionState is used to verify the TLS ciphersuite and to set
// the Request.TLS field in Handlers.
//
// ServeConn does not support h2c by itself. Any h2c support must be
// implemented in terms of providing a suitably-behaving net.Conn.
//
// The opts parameter is optional. If nil, default values are used.
func (s *http2Server) ServeConn(c net.Conn, opts *http2ServeConnOpts) {
	baseCtx, cancel := http2serverConnBaseContext(c, opts)
	defer cancel()

	sc := &http2serverConn{
		srv:           s,
		hs:            opts.baseConfig(),
		conn:          c,
		baseCtx:       baseCtx,
		remoteAddrStr: c.RemoteAddr().String(),
		bw:            http2newBufferedWriter(c),
		handler:       opts.handler(),
		// streams:                     make(map[uint32]*stream),
		// readFrameCh:                 make(chan readFrameResult),
		// wantWriteFrameCh:            make(chan FrameWriteRequest, 8),
		// serveMsgCh:                  make(chan interface{}, 8),
		// wroteFrameCh:                make(chan frameWriteResult, 1), // buffered; one send in writeFrameAsync
		// bodyReadCh:                  make(chan bodyReadMsg),         // buffering doesn't matter either way
		// doneServing:                 make(chan struct{}),
		// clientMaxStreams:            math.MaxUint32, // Section 6.5.2: "Initially, there is no limit to this value"
		// advMaxStreams:               s.maxConcurrentStreams(),
		// initialStreamSendWindowSize: initialWindowSize,
		// maxFrameSize:                initialMaxFrameSize,
		// serveG:                      newGoroutineLock(),
		// pushEnabled:                 true,
		// sawClientPreface:            opts.SawClientPreface,
	}

	s.state.registerConn(sc)
	defer s.state.unregisterConn(sc)

	// The net/http package sets the write deadline from the
	// http.Server.WriteTimeout during the TLS handshake, but then
	// passes the connection off to us with the deadline already set.
	// Write deadlines are set per stream in serverConn.newStream.
	// Disarm the net.Conn write deadline here.
	if sc.hs.WriteTimeout != 0 {
		sc.conn.SetWriteDeadline(time.Time{})
	}

	if s.NewWriteScheduler != nil {
		sc.writeSched = s.NewWriteScheduler()
	} else {
		sc.writeSched = http2newRoundRobinWriteScheduler()
	}

	// These start at the RFC-specified defaults. If there is a higher
	// configured value for inflow, that will be updated when we send a
	// WINDOW_UPDATE shortly after sending SETTINGS.
	sc.flow.add(http2initialWindowSize)
	sc.inflow.init(http2initialWindowSize)
	sc.hpackEncoder = hpack.NewEncoder(&sc.headerWriteBuf)
	sc.hpackEncoder.SetMaxDynamicTableSizeLimit(s.maxEncoderHeaderTableSize())

	fr := http2NewFramer(sc.bw, c)
	if s.CountError != nil {
		fr.countError = s.CountError
	}
	fr.ReadMetaHeaders = hpack.NewDecoder(s.maxDecoderHeaderTableSize(), nil)
	fr.MaxHeaderListSize = sc.maxHeaderListSize()
	fr.SetMaxReadFrameSize(s.maxReadFrameSize())
	sc.framer = fr

	// TODO

	sc.serve()
}

func http2serverConnBaseContext(c net.Conn, opts *http2ServeConnOpts) (ctx context.Context, cancel func()) {
	ctx, cancel = context.WithCancel(opts.context())
	ctx = context.WithValue(ctx, LocalAddrContextKey, c.LocalAddr())
	if hs := opts.baseConfig(); hs != nil {
		ctx = context.WithValue(ctx, ServerContextKey, hs)
	}
	return
}

type http2serverConn struct {
	// Immutable:
	srv     *http2Server
	hs      *Server
	conn    net.Conn
	bw      *http2bufferedWriter // writing to conn
	handler Handler
	baseCtx context.Context
	framer  *http2Framer
	// doneServing      chan struct{}          // closed when serverConn.serve ends
	// readFrameCh      chan readFrameResult   // written by serverConn.readFrames
	// wantWriteFrameCh chan FrameWriteRequest // from handlers -> serve
	// wroteFrameCh     chan frameWriteResult  // from writeFrameAsync -> serve, tickles more frame writes
	// bodyReadCh       chan bodyReadMsg       // from handlers -> serve
	// serveMsgCh       chan interface{}       // misc messages & code to send to / run on the serve loop
	flow   http2outflow // conn-wide (not stream-specific) outbound flow control
	inflow http2inflow  // conn-wide inbound flow control
	// tlsState         *tls.ConnectionState   // shared by all handlers, like net/http
	remoteAddrStr string
	writeSched    http2WriteScheduler

	// // Everything following is owned by the serve loop; use serveG.check():
	// serveG                      goroutineLock // used to verify funcs are on serve()
	// pushEnabled                 bool
	// sawClientPreface            bool // preface has already been read, used in h2c upgrade
	// sawFirstSettings            bool // got the initial SETTINGS frame after the preface
	// needToSendSettingsAck       bool
	// unackedSettings             int    // how many SETTINGS have we sent without ACKs?
	// queuedControlFrames         int    // control frames in the writeSched queue
	// clientMaxStreams            uint32 // SETTINGS_MAX_CONCURRENT_STREAMS from client (our PUSH_PROMISE limit)
	// advMaxStreams               uint32 // our SETTINGS_MAX_CONCURRENT_STREAMS advertised the client
	// curClientStreams            uint32 // number of open streams initiated by the client
	// curPushedStreams            uint32 // number of open streams initiated by server push
	// curHandlers                 uint32 // number of running handler goroutines
	// maxClientStreamID           uint32 // max ever seen from client (odd), or 0 if there have been no client requests
	// maxPushPromiseID            uint32 // ID of the last push promise (even), or 0 if there have been no pushes
	// streams                     map[uint32]*stream
	// unstartedHandlers           []unstartedHandler
	// initialStreamSendWindowSize int32
	// maxFrameSize                int32
	// peerMaxHeaderListSize       uint32            // zero means unknown (default)
	// canonHeader                 map[string]string // http2-lower-case -> Go-Canonical-Case
	// canonHeaderKeysSize         int               // canonHeader keys size in bytes
	// writingFrame                bool              // started writing a frame (on serve goroutine or separate)
	// writingFrameAsync           bool              // started a frame on its own goroutine but haven't heard back on wroteFrameCh
	// needsFrameFlush             bool              // last frame write wasn't a flush
	// inGoAway                    bool              // we've started to or sent GOAWAY
	// inFrameScheduleLoop         bool              // whether we're in the scheduleFrameWrite loop
	// needToSendGoAway            bool              // we need to schedule a GOAWAY frame write
	// goAwayCode                  ErrCode
	// shutdownTimer               *time.Timer // nil until used
	// idleTimer                   *time.Timer // nil if unused

	// Owned by the writeFrameAsync goroutine:
	headerWriteBuf bytes.Buffer
	hpackEncoder   *hpack.Encoder

	// // Used by startGracefulShutdown.
	// shutdownOnce sync.Once
}

func (sc *http2serverConn) maxHeaderListSize() uint32 {
	n := sc.hs.MaxHeaderBytes
	if n <= 0 {
		n = DefaultMaxHeaderBytes
	}
	// http2's count is in a slightly different unit and includes 32 bytes per pair.
	// So, take the net/http.Server value and pad it up a bit, assuming 10 headers.
	const perFieldOverhead = 32 // per http2 spec
	const typicalHeaders = 10   // conservative
	return uint32(n + typicalHeaders*perFieldOverhead)
}

func (sc *http2serverConn) serve() {

}

func http2strSliceContains(ss []string, s string) bool {
	for _, v := range ss {
		if v == s {
			return true
		}
	}
	return false
}

// WriteScheduler is the interface implemented by HTTP/2 write schedulers.
// Methods are never called concurrently.
type http2WriteScheduler interface {
}

// writeQueue is used by implementations of WriteScheduler.
type http2writeQueue struct {
}

// PriorityWriteSchedulerConfig configures a priorityWriteScheduler.
type http2PriorityWriteSchedulerConfig struct {
}

// NewPriorityWriteScheduler constructs a WriteScheduler that schedules
// frames by following HTTP/2 priorities as described in RFC 7540 Section 5.3.
// If cfg is nil, default options are used.
func http2NewPriorityWriteScheduler(cfg *http2PriorityWriteSchedulerConfig) http2WriteScheduler {
	ws := &http2priorityWriteScheduler{}
	return ws
}

type http2priorityWriteScheduler struct {
}

type http2roundRobinWriteScheduler struct {
	// streams maps stream ID to a queue.
	streams map[uint32]*http2writeQueue
}

func http2newRoundRobinWriteScheduler() http2WriteScheduler {
	ws := &http2roundRobinWriteScheduler{
		streams: make(map[uint32]*http2writeQueue),
	}
	return ws
}
